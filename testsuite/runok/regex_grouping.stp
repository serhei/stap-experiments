#! stap -p5

global n
global pass, fail

function print_groups() {
  for (i = 0; i < ngroups(); i++) printf("'%s' ", matched(i))
}

@define test(code, regexp, str) %(
  passed = 1; match_fail = 0
  result = (@str =~ @regexp)
  if (result != !@code) { passed = 0; match_fail = 1 }
%)

@define check_equal(n, str1, str2) %(
  // intercept 'group does not exist' error
  if (@n >= ngroups()) { passed = 0 }
  else if (@str1 != @str2) { passed = 0 }
%)

@define tally_result(code, regexp, str) %(
  // TODOXXX: may also want to print *expected* group values
  n++
  if (passed) {
    printf("regex PASS: #%d: %s %s %s", n, @str, (@code ? "!~" : "=~"), @regexp)
    if (@code == 0) {
      printf(" with %d groups ", ngroups())
      print_groups()
    }
    pass++
  } else if (match_fail) {
    printf("regex FAIL: #%d: %s %s %s\n", n, @str, (@code ? "!~" : "=~"), @regexp)
    fail++
  } else {
    printf("regex FAIL (grouping): #%d: %s %s %s with %d groups ", n, @str, (@code ? "!~" : "=~"), @regexp, ngroups())
	print_groups()
	fail++
  }
  printf("\n")
%)

@define check(code, regex, str) %(
  @test(@code, @regex, @str)
  @tally_result(@code, @regex, @str)
%)

@define test0 (regex, str, grp0) %(
  @test(0, @regex, @str)
  @check_equal(0, matched(0), @grp0)
%)

@define check0 (regex, str, grp0) %(
  @test0(@regex, @str, @grp0)
  @tally_result(0, @regex, @str)
%)

@define test1 (regex, str, grp0, grp1) %(  
  @test0(@regex, @str, @grp0)
  @check_equal(1, matched(1), @grp1)
%)

@define check1 (regex, str, grp0, grp1) %(
  @test1(@regex, @str, @grp0, @grp1)
  @tally_result(0, @regex, @str)
%)

@define check2 (regex, str, grp0, grp1, grp2) %(  
  @test1(@regex, @str, @grp0, @grp1)
  @check_equal(2, matched(2), @grp2)
  @tally_result(0, @regex, @str)
%)

probe begin {
# tests for longest-match behaviour / TODO: need to clarify POSIX/PCRE rules
# TODOXXX: check against different regex implementations
  @check0("a*", "aaa", "aaa")
  @check0("a?", "aaa", "a")
  @check1("(ab)*", "abab", "abab", "ab")
  @check1("(ab)?", "ab", "ab", "ab")
  @check1("(ab)?", "abab", "ab", "ab")
  @check1("c(ab)*", "cabab", "cabab", "ab")
  @check1("c(ab)?", "cab", "cab", "ab")
  @check1("c(ab)?", "cabab", "cab", "ab")
  @check1("(a*)a*a", "aaa", "aaa", "aa")
  @check1("re(gex)", "regex", "regex", "gex")
  @check0("(long|longer)", "longer", "longer")
  @check(1, "regex", "unrelated")
  @check0("a|b", "ab", "a")
  @check0("a+|b", "baaab", "b")
  @check0("a*|b", "aaab", "aaa")

# TODO: is this right? i.e. does 'first alternative' trump 'longest-match'?
# note that Open Group standard seems to just say to use the longest match out of the ones starting at the earliest point
  @check0("a*|b", "baaab", "")
  @check0("b|a*", "baaab", "b")
  @check1("(.*).*", "abcdef", "abcdef", "abcdef")

# TODO: incorporate ALL tests from regex.stp
  /* from former systemtap.base/regexp.exp */
  @check0("\\\\", "\\", "\\")
  @check0("abc", "xabcy", "abc")
  @check0("ab*bc", "abbbbc", "abbbbc")
  @check0("ab?bc", "abbc", "abbc")
  @check(1, "^abc$", "abcc")
  @check(1, "a[b-d]e", "abd")
  @check0("a[b-d]e", "ace", "ace")
  @check0("a\\(*b", "ab", "ab")
  @check0("a\\(*b", "a((b", "a((b")
  @check1("(a+|b)*", "ab", "ab", "b")
  @check1("(a+|b)+", "ab", "ab", "b")
  @check1("([abc])*d", "abbbcd", "abbbcd", "c")

  @check(1, "^(ab|cd)e", "abcde")
  @check1("(ab|cd)e", "abcde", "cde", "cd")  # variant..
  @check1("(ab|cd)e$", "abcde", "cde", "cd") # variant..

  @check0("[A-Za-z_][A-Za-z0-9_]*", "alpha", "alpha")

  @check2("(bc+d$|ef*g.|h?i(j|k))", "ij", "ij", "ij", "j")
  @check(1, "(bc+d$|ef*g.|h?i(j|k))", "effg")
  @check2("(bc+d$|ef*g.|h?i(j|k))", "00effg12", "effg1", "effg1", "")
  @check2("(bc+d$|ef*g.|h?i(j|k))", "bcccd", "bcccd", "bcccd", "") # variant..

  @check(0, "(((((((((a)))))))))", "a") # TODO: check all the groups?
  @check(1, "\\((.*),", "(.*)\\)")
  @check(1, "[k]", "ab")
  @check0("abcd", "abcd", "abcd")
  @check1("a(bc)d", "abcd", "abcd", "bc")

# TODO: further tests...

  exit()
}

probe end {
  printf ("\nregex total PASS: %d, FAIL: %d\n", pass, fail)
  if (fail > 0) error ("Oops")
}
